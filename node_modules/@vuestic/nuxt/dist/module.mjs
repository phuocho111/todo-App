import { useNuxt, addPluginTemplate, addImports, addComponent, resolveAlias, defineNuxtModule } from '@nuxt/kit';
import { existsSync } from 'fs';
import { dirname, parse, resolve } from 'pathe';
import { fileURLToPath } from 'url';

const VUESTIC_DEFAULT_FONTS = [
  { rel: "stylesheet", href: "https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,400;1,700&display=swap" },
  { rel: "stylesheet", href: "https://fonts.googleapis.com/icon?family=Material+Icons&display=swap" }
];
const registerDefaultFonts = (nuxt) => {
  nuxt.options.app = nuxt.options.app || {};
  nuxt.options.app.head = nuxt.options.app.head || {};
  nuxt.options.app.head.link = nuxt.options.app.head.link || [];
  nuxt.options.app.head.link.push(...VUESTIC_DEFAULT_FONTS);
};
const useVuesticCSS = (options) => {
  const nuxt = useNuxt();
  if (Array.isArray(options.css)) {
    nuxt.options.css.push("vuestic-ui/styles/essential.css");
    options.css.forEach((cssModuleName) => {
      nuxt.options.css.push(`vuestic-ui/styles/${cssModuleName}.css`);
    });
  } else if (options.css === true) {
    nuxt.options.css.push("vuestic-ui/dist/styles/index.css");
  }
  if (options.fonts) {
    registerDefaultFonts(nuxt);
  }
};

const distDir = dirname(fileURLToPath(import.meta.url));

const resolveInRuntime = (path) => {
  const { ext, name, dir } = parse(path);
  if (ext === ".mjs") {
    const r = resolve(distDir, `${dir}/${name}.ts`);
    if (existsSync(r)) {
      return r;
    }
  }
  return resolve(distDir, path);
};

const useVuesticPlugin = (options) => {
  const pluginPath = resolveInRuntime("./runtime/plugin.mjs");
  addPluginTemplate({
    src: pluginPath,
    filename: pluginPath.split("/").pop(),
    // Use JSON.stringify() here, because it will be inserted in ejs template as string. Then we will JSON.parse it.
    options: {
      value: JSON.stringify(options)
    }
  });
};

const importNames$1 = [
  "useGlobalConfig",
  "useI18nConfig",
  "useBreakpoint",
  "useColors",
  "useToast",
  "useModal"
];

const useVuesticComposables = () => {
  const composablesFrom = resolveInRuntime("./runtime/composables.mjs");
  const autoImportsList = importNames$1.map((item) => ({
    name: item,
    // TODO: We probably need to rename all composables to `useVuesticGlobalConfig`, `useVuesticModal`, etc.
    // Let's have it as an option in the future if there will be any issues. 
    as: item,
    from: composablesFrom
  }));
  addImports(autoImportsList);
};

const importNames = [
  "VaAccordion",
  "VaAffix",
  "VaAlert",
  "VaAppBar",
  "VaAspectRatio",
  "VaAvatar",
  "VaAvatarGroup",
  "VaBacktop",
  "VaBadge",
  "VaBreadcrumbs",
  "VaBreadcrumbsItem",
  "VaButton",
  "VaButtonDropdown",
  "VaButtonGroup",
  "VaButtonToggle",
  "VaCard",
  "VaCardActions",
  "VaCardContent",
  "VaCardTitle",
  "VaCardBlock",
  "VaCarousel",
  "VaCheckbox",
  "VaChip",
  "VaCollapse",
  "VaColorIndicator",
  "VaColorInput",
  "VaColorPalette",
  "VaConfig",
  "VaContent",
  "VaCounter",
  "VaDataTable",
  "VaDateInput",
  "VaDatePicker",
  "VaDivider",
  "VaDropdown",
  "VaDropdownContent",
  "VaFileUpload",
  "VaForm",
  "VaHover",
  "VaIcon",
  "VaImage",
  "VaInfiniteScroll",
  "VaInnerLoading",
  "VaInput",
  "VaLayout",
  "VaList",
  "VaListItem",
  "VaListItemLabel",
  "VaListItemSection",
  "VaListLabel",
  "VaListSeparator",
  "VaMessageList",
  "VaModal",
  "VaNavbar",
  "VaNavbarItem",
  "VaOptionList",
  "VaPagination",
  "VaParallax",
  "VaPopover",
  "VaProgressBar",
  "VaProgressCircle",
  "VaRadio",
  "VaRating",
  "VaSelect",
  "VaSeparator",
  "VaSidebar",
  "VaSidebarItem",
  "VaSidebarItemContent",
  "VaSidebarItemTitle",
  "VaSlider",
  "VaSkeleton",
  "VaSkeletonGroup",
  "VaSpacer",
  "VaSplit",
  "VaSwitch",
  "VaTabs",
  "VaTab",
  "VaTimeInput",
  "VaTimeline",
  "VaTimelineItem",
  "VaTimePicker",
  "VaTreeView",
  "VaScrollContainer",
  "VaValue",
  "VaVirtualScroller",
  "VaStepper",
  "VaTextarea"
];

const useVuesticComponents = () => {
  importNames.forEach((name) => {
    addComponent({
      name,
      export: name,
      filePath: `vuestic-ui`
    });
  });
};

const useTranspile = () => {
  const nuxt = useNuxt();
  nuxt.options.build.transpile.push("vuestic-ui");
};

const useConfigFile = async () => {
  const root = resolveAlias("~/");
  const configPath = resolve(root, "vuestic.config.ts");
  const nuxt = useNuxt();
  if (existsSync(configPath)) {
    nuxt.options.alias["#vuestic-config"] = configPath;
  } else {
    nuxt.options.alias["#vuestic-config"] = resolveInRuntime("./runtime/config.mjs");
  }
  nuxt.options.watch.push("vuestic.config.ts");
};

const module = defineNuxtModule({
  meta: {
    name: "@vuestic/nuxt",
    configKey: "vuestic",
    compatibility: {
      nuxt: "^3.3.0"
    }
  },
  defaults: {
    config: {},
    css: ["smart-helpers", "typography"],
    fonts: true,
    themeCookieKey: "vuestic-theme"
  },
  setup(options) {
    useConfigFile();
    useVuesticCSS(options);
    useVuesticPlugin(options);
    useVuesticComponents();
    useVuesticComposables();
    useTranspile();
  }
});

export { module as default };
