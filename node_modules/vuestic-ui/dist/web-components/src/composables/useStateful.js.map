{"version":3,"file":"useStateful.js","sources":["../../../../src/composables/useStateful.ts"],"sourcesContent":["import { ref, computed, watch, PropType, Ref } from 'vue'\n\nexport type StatefulProps = {\n  stateful: boolean\n}\n\nexport type StatefulOptions<T> = {\n  eventName?: string\n  /** @deprecated set default value for prop, not here */\n  defaultValue?: T\n}\n\ntype NonUndefined<T extends any> = T extends undefined ? never : T\n\n/**\n * You could add these props to any component by destructuring them inside props option.\n * @example\n * props: { ...useStatefulProps, componentsOwnProp, etc. }\n * It's better to add props at the beginning, to make sure that Component own props will be used instead in case of collision\n */\nexport const useStatefulProps = {\n  stateful: { type: Boolean as PropType<boolean>, default: false },\n  modelValue: { type: undefined as any },\n}\n\nexport const createStatefulProps = (statefulDefault = false) => {\n  return {\n    stateful: { type: Boolean as PropType<boolean>, default: statefulDefault },\n  }\n}\n\nexport const useStatefulEmits = ['update:modelValue'] as const\n\n/**\n * Returns `valueComputed` that is proxy for `modelValue` or given key of the props\n * if `stateful` prop is `false`\n * Record<any, any> & Record<'modelValue', T>\n */\nexport const useStateful = <\n  T,\n  D extends any,\n  O extends StatefulOptions<D>,\n  Key extends string = 'modelValue',\n  P extends StatefulProps & { [key in Key]?: T } = StatefulProps & { [key in Key]?: T },\n>(\n    props: P,\n    emit: (name: `update:${Key}`, ...args: any[]) => void,\n    key: Key = 'modelValue' as Key,\n    options: O = {} as O,\n  ) => {\n  const { defaultValue, eventName } = options\n  const event = (eventName || `update:${key.toString()}`) as `update:${Key}`\n  const valueState = ref(defaultValue === undefined ? props[key] : defaultValue) as Ref\n  let unwatchModelValue: Function\n\n  const watchModelValue = () => {\n    unwatchModelValue = watch(() => props[key], (modelValue) => {\n      valueState.value = modelValue\n    })\n  }\n\n  watch(() => props.stateful, (stateful: boolean) => {\n    stateful ? watchModelValue() : unwatchModelValue?.()\n  }, { immediate: true })\n\n  const valueComputed = computed<unknown extends O['defaultValue'] ? P[Key] : NonUndefined<P[Key]>>({\n    get: () => {\n      if (props.stateful) { return valueState.value }\n\n      return props[key]\n    },\n    set: (value) => {\n      if (props.stateful) { valueState.value = value }\n\n      emit(event, value)\n    },\n  })\n\n  return { valueComputed }\n}\n"],"names":[],"mappings":";AAoBO,MAAM,mBAAmB;AAAA,EAC9B,UAAU,EAAE,MAAM,SAA8B,SAAS,MAAM;AAAA,EAC/D,YAAY,EAAE,MAAM,OAAiB;AACvC;AAEa,MAAA,sBAAsB,CAAC,kBAAkB,UAAU;AACvD,SAAA;AAAA,IACL,UAAU,EAAE,MAAM,SAA8B,SAAS,gBAAgB;AAAA,EAAA;AAE7E;AAEa,MAAA,mBAAmB,CAAC,mBAAmB;AAOvC,MAAA,cAAc,CAOvB,OACA,MACA,MAAW,cACX,UAAa,OACV;AACC,QAAA,EAAE,cAAc,UAAc,IAAA;AACpC,QAAM,QAAS,aAAa,UAAU,IAAI,SAAS;AACnD,QAAM,aAAa,IAAI,iBAAiB,SAAY,MAAM,GAAG,IAAI,YAAY;AACzE,MAAA;AAEJ,QAAM,kBAAkB,MAAM;AAC5B,wBAAoB,MAAM,MAAM,MAAM,GAAG,GAAG,CAAC,eAAe;AAC1D,iBAAW,QAAQ;AAAA,IAAA,CACpB;AAAA,EAAA;AAGH,QAAM,MAAM,MAAM,UAAU,CAAC,aAAsB;AACtC,eAAA,oBAAoB;AAAA,EAAoB,GAClD,EAAE,WAAW,KAAA,CAAM;AAEtB,QAAM,gBAAgB,SAA4E;AAAA,IAChG,KAAK,MAAM;AACT,UAAI,MAAM,UAAU;AAAE,eAAO,WAAW;AAAA,MAAM;AAE9C,aAAO,MAAM,GAAG;AAAA,IAClB;AAAA,IACA,KAAK,CAAC,UAAU;AACd,UAAI,MAAM,UAAU;AAAE,mBAAW,QAAQ;AAAA,MAAM;AAE/C,WAAK,OAAO,KAAK;AAAA,IACnB;AAAA,EAAA,CACD;AAED,SAAO,EAAE,cAAc;AACzB;"}